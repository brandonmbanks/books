# The Rust Programming Language

## Common Programming Concepts
### 3.1 Variables and Mutability

Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.

We can `shadow` a variable by using the same variable’s name and repeating the use of the let keyword
By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.
The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name.
```rust
let spaces = "   ";
let spaces = spaces.len();
```
### 3.2 Data Types
A scalar type represents a single value. Rust has four primary scalar types: `integers`, `floating-point numbers`, `Booleans`, and `characters`.

Integers can either be signed and unsigned refer to whether it’s possible for the number to be negative.
```rust
let signed: i8 = -10;
let usigned: u8 = 100;
```

Each signed variant can store numbers from `-(2^(n - 1))` to `2^(n - 1) - 1` inclusive, where n is the number of bits that variant uses. So an i8 can store numbers from `-(2^7)` to `2^7 - 1`, which equals -128 to 127. Unsigned variants can store numbers from `0` to `2^(n - 1)`, so a u8 can store numbers from 0 to 28 - 1, which equals 0 to 255.

Number literals can also use `_` as a visual separator to make the number easier to read, such as `1_000`, which will have the same value as if you had specified `1000`.
```rust
let thousand: u32 = 1_000;
```

When you’re compiling in release mode with the `--release` flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping.

Rust’s floating-point types are `f32` and `f64`, which are 32 bits and 64 bits in size, respectively. The default type is `f64` because on modern CPUs it’s roughly the same speed as `f32` but is capable of more precision. All floating-point types are signed.

Compound types can group multiple values into one type. Rust has two primitive compound types: `tuples` and `arrays`.

Tuples
```rust
let x: (i32, f64, u8) = (500, 6.4, 1);

let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;
```
Arrays

Unlike arrays in some other languages, arrays in Rust have a fixed length.

A `vector` is a similar collection type provided by the standard library that is allowed to grow or shrink in size. If you’re unsure whether to use an array or a vector, chances are you should use a vector.

You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:
```rust
let a = [3; 5];
```

### 3.3 Functions

`Statements` are instructions that perform some action and do not return a value. `Expressions` evaluate to a resulting value.
